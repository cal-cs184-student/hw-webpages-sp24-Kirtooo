<html>
	<head>
		Homework 3: Pathtracer
	</head>
	<p>
		Leo Yuan & David Long
	</p>
	<p>
		link: https://cal-cs184-student.github.io/hw-webpages-sp24-Kirtooo/
	</p>
	<body>
		<h2>Overview:</h2>
		<p>
			In this project, we implemented Bezier curve and surface, and triangle mesh methods. We have a better understanding of those concepts and really enjoyed the homework.
		</p>
		<h2>Part1: </h2>
		<h3>ray generation: </h3>
		<p>
			In this part, we are converting 2-D image coordinates into 3-D camera space. Specifically, we have the sensor on Z = -1 plane and using hFov and vFov as view angle along X and Y axis.
			Having those information, we can then calculate the corresponding coordinates of the input (x, y) on the camera space. 
			Afterwards, we normalize this direction vector of the ray and use the provided <code>c2w</code> matrix to transform the ray to world space.
			Lastly, as mentioned in spec, we set the <code>min_t</code> and <code>max_t</code> parameter of the ray.
		</p>
		<h3>rendering pipeline: </h3>
		<p>
			We use <code>ns_aa</code> as number of samples for a pixel to estimate the integral of radiance. 
			Specifically, we use each of the normalized sample points to generate a ray and estimate the radiance for the ray and 
			then get the integral by averaging those radiance of ray. Lastly, we update the sample buffer.
		</p>
		<h3>triangle intersection</h3>
		<p>
			For this part, we used Möller–Trumbore intersection algorithm. 
			Specifically, we first checked if the ray is parallel to the triangle by calculating the dot product of one of the edge and the cross product of the other edge and ray.
			Afterwards, we calculate the barycentric coordinates of the intersection point along the edges of the triangle.
			We then determined the point is inside the triangle if the barycentric coordinate is in range [0,1].
			Lastly, we calculate the t vector equal the inverse of determinant dot the second edge of triangle dot the cross product of vector from origin to vertice of the triangle and the first edge of triangle.
		</p>
		<style>
			.column {
				float: left;
				width: 30.33%;
				padding: 5px;
			  }
			  
			  /* Clear floats after image containers */
			  .row::after {
				content: "";
				clear: both;
				display: table;
			  }

			  .column2 {
				float: left;
				width: 40%;
				padding: 5px;
			  }
		</style>
		<div class="row">
			<div class="column">
			  <img src="image/CBempty.png" style="width:100%">
			</div>
			<div class="column">
			  <img src="image/CBspheres.png"  style="width:100%">
			</div>
			<div class="column">
			  <img src="image/CBcoil.png" style="width:100%">
			</div>
		</div>
		<h2>Part2: </h2>
		<p>
			The first part of this task is to construct the BVH.
			In this part, we first iterate through all the primitives to generate the bounding box that contains all of the primitives.
			We then check for the number of primitives and create a new <code>BVHNode</code> if the number of primitives is smaller than <code>max_leaf_size</code>.
			If we have more primitives than max_leaf_size, we want to recursively construct the tree.
			Specifically, we pick the longest distance and chose the heuristic that split on median and we get the median by sorting the primitives based on their centroid and the chosen axis.
		</p>
		<p>
			The second part of this task is to check if the ray intersect with the bounding box.
			In this part, we calculated the time of intersection of the ray with each of the x, y, z planes,
			and we picked the largest <code>t_min</code> and smallest <code>t_max</code> to find the smallest bound.
			If at a point that the max t_min is greater than min t_max, we return false.
		</p>
		<P>
			The last part of this task is to check for the intersect of the ray and BVH.
			To check if the ray has intersection with the node, we first check if the ray is intersect with the bounding box of the node, return false if it doesn't intersects.
			If the ray intersects with the bounding box and the node is a leaf node, we iterate through all the primitives in the node and return ture if the ray is intersects with any of the primitives in the node.
			Lastly, if the node is a internal node, we recursively call this function to check for both of its children. 
			To get the intersection data, we implemented the intersect function with the same idea as has_intersect function but we are calling the intersect funtions on primitives to update the intersection data.
		</P>
		<div class="row">
			<div class="column">
			  <img src="image/cow.png" style="width:100%">
			</div>
			<div class="column">
			  <img src="image/maxplanck.png"  style="width:100%">
			</div>
			<div class="column">
			  <img src="image/CBlucy.png" style="width:100%">
			</div>
		</div>
		<h3>Compare rendering time</h3>
		<img src="image/compare.png">
		<p>
			By rendering the same file with and without BVH, we can clearly see that BVH acceleration makes the rendering time dramatically faster.
			This is because that we are testing intersects with every single primitives if we dont use BVH. 
			With BVH, we are able to first filter out primitives with the bounding box and only testing intersects with the primitives in the leaf node, and this make the rendering process a lot faster.
		</p>
		<h2>Part3: </h2>
		<h3>Direct Lighting with Uniform Hemisphere Sampling</h3>
		<p>
			We iterate through number of samples. Then, we calculate wi with <code>hemisphereSampler</code>and world space coordinates of wi. 
			We then initiates the ray for sampled direction. 
			Afterwards, we check if the sampled ray intersects with the light source by calling the intersect function we implemented.
			If there is an intersection, we use the reflection equation to calculate the ourgoing light and add it to the total l_out.
			Specifically, we since we are doing uniform Hemispher Sampling, we chose p = 2*pi.
		</p>
		<div class="row">
			<div class="column2">
			  <img src="image/CBbunny_16_8.png" style="width:100%">
			</div>
			<div class="column2">
			  <img src="image/CBbunny_64_32.png"  style="width:100%">
			</div>
		</div>
		<h3>Direct Lighting by Importance Sampling Lights</h3>
		<p>

		</p>
		<!-- <h2>Task4:</h2>
		<p>
			I implemented edge flip operation based on the screenshot below. I first obtained all of the half edges, vertices, edges, and faces before flipping. 
			Then according to what the triangle mesh should look like after flipping in the screenshot, I reassigned edges, vertices, edges, and faces. 
			I think one interesting thing is that the pointers should be assigned carefully. I encountered a bug related to missing triangle when implementing, 
			and it was due to incorrect pointer assignment. So I think the debugging trick I found most useful was simply being careful with pointers.
		</p>
		<img src="image/task4.png">
		<div style="display: flex; justify-content: space-around; align-items: flex-start; flex-wrap: wrap;">
		  <figure style="max-width: 40%; text-align: center;">
		    <img src="image/before.png" style="width: 100%; height: auto;">
		    <figcaption>Before Flip</figcaption>
		  </figure>
		  <figure style="max-width: 40%; text-align: center;">
		    <img src="image/flip1.png" style="width: 100%; height: auto;">
		    <figcaption>Flip an edge once</figcaption>
		  </figure>
		  <figure style="max-width: 40%; text-align: center;">
		    <img src="image/flip2.png" style="width: 100%; height: auto;">
		    <figcaption>Flip its Neighboring Edge</figcaption>
		  </figure>
		  <figure style="max-width: 40%; text-align: center;">
		    <img src="image/flip3.png" style="width: 100%; height: auto;">
		    <figcaption>Flip Multiple Edges</figcaption>
		  </figure>
		</div>

		<h2>Task5:</h2>
		<p>
			I implemented edge split operation following a similar approach to task 4. 
			I first obtained all of the half edges, vertices, edges, and faces before flipping. 
			Then I added one new vertex m, three new edges, and six new half edges resulting from the edge splitting operation. 
			Similar to task 4, I reassign pointers if needed. 
			My implementation does not involve deleting elements from the origin triangle mesh in order to avoid segmentation faults due to problematic pointer removals. 
			My debugging approach is similar to that I mentioned in task 4. 
		</p>
		<div style="display: flex; justify-content: space-around; align-items: flex-start; flex-wrap: wrap;">
		  <figure style="max-width: 40%; text-align: center;">
		    <img src="image/split1.png" style="width: 100%; height: auto;">
		    <figcaption>Split an Edge</figcaption>
		  </figure>
		  <figure style="max-width: 40%; text-align: center;">
		    <img src="image/split2.png" style="width: 100%; height: auto;">
		    <figcaption>Split its Neighboring Edge</figcaption>
		  </figure>
		  <figure style="max-width: 40%; text-align: center;">
		    <img src="image/split_and_flip1.png" style="width: 100%; height: auto;">
		    <figcaption>Flip after Split</figcaption>
		  </figure>
		  <figure style="max-width: 40%; text-align: center;">
		    <img src="image/split_and_flip2.png" style="width: 100%; height: auto;">
		    <figcaption>Flip after Split</figcaption>
		  </figure>
		</div>
		<h2>Task6:</h2>
		<p>
			I implemented the loop subdivision following the instructions on the spec and comments in the upsample function. 
		   	I first computed new positions for all the vertices in the input mesh, using the Loop subdivision rule (u=3/16 if n=3, 3/(8n) otherwise), and stored them in Vertex::newPosition. 
		   	For step 2, I computed the updated positions for the midpoints of edges (3/8 * (A + B) + 1/8 * (C + D)) and stored them in Edge::newPosition. Then I created a list to track original edges because the mesh.edges list will be modified in the splitting process.
			For step 3, I splitted every edge in the mesh and update the new vertices' positions, marking the “isNew” attribute of new edges created in this process as true. 
			For step 4, Flip any new edge that connects an old and new vertex. 
			For step 5, I copied the new vertex positions into the Vertex::position and reset “isNew” for the next iteration of subdivision. 
			I did not encounter any bugs when implementing task 6, so I cannot really say which debugging trick I found most useful. 
			
			Sharp corners in the original mesh tend to become smoother and less pronounced with each iteration of Loop subdivision. This is because the algorithm averages the positions of the vertices, which naturally rounds off sharp angles. 
			Similar to sharp corners, sharp edges also become smoother with Loop subdivision. The sharpness of an edge is reduced with each subdivision step, as new vertices are introduced along the edge and existing vertices are moved to average positions. 
			To reduce the smoothing effect on sharp features, one could pre-split or insert extra edges around the areas that are intended to remain sharp before applying the subdivision. This technique can help in maintaining some of the mesh's original sharpness by creating a localized increase in vertex density, which affects the averaging calculations during subdivision.
			Without Pre-process, we can see that the triangles on the same face of the cube looks slightly asymmetric and the cube also looks assymetric. We tried to split all the diagnal edge on the cube to Pre-process the cube. After doing so, we can see that the cube looks more symmetric.
		</p>
		<div style="display: flex; justify-content: space-around; align-items: flex-start; flex-wrap: wrap;">
		  <figure style="max-width: 40%; text-align: center;">
		    <img src="image/cube.png" style="width: 100%; height: auto;">
		    <figcaption>Cube after Pre-processed</figcaption>
		  </figure>
		  <figure style="max-width: 40%; text-align: center;">
		    <img src="image/cube_preprocessed.png" style="width: 100%; height: auto;">
		    <figcaption>Upsample Pre-processed Cube</figcaption>
		  </figure>
		  <figure style="max-width: 40%; text-align: center;">
		    <img src="image/before.png" style="width: 100%; height: auto;">
		    <figcaption>Teapot beofore Upsample</figcaption>
		  </figure>
		  <figure style="max-width: 40%; text-align: center;">
		    <img src="image/teapot_smooth.png" style="width: 100%; height: auto;">
		    <figcaption>Teapot after Upsample</figcaption>
		  </figure>
		</div> -->
		
	</body>
	
</html>
